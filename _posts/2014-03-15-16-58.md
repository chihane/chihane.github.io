---
layout: post
title: 设计模式，1/23，单例模式
date: 2014-03-15 16:58:00
categories: cnblogs
---

<p>顾名思义，只有一个实例的模式。</p>
<p>禅那本书举了个好例子，皇帝，这应该单独写一个类，但是应该是唯一的，只有一个实例，不能让人随便new出很多个来。</p>
<p>解决方法就是限制构造函数的权限，本来new对象就是用构造函数的，既然构造函数不能访问了，那自然就不能new对象了。</p>
<p>但是又不能一个实例都没有，所以：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('abd2bb2b-6993-4924-a49f-1c6a3c73063a')"><img id="code_img_closed_abd2bb2b-6993-4924-a49f-1c6a3c73063a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_abd2bb2b-6993-4924-a49f-1c6a3c73063a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('abd2bb2b-6993-4924-a49f-1c6a3c73063a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_abd2bb2b-6993-4924-a49f-1c6a3c73063a" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Singleton {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Singleton singleton = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Singleton();
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> Singleton() {}
</span><span style="color: #008080;"> 5</span>     
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Singleton getInstance() {
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> singleton;
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span>     
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> doSomething() {
</span><span style="color: #008080;">11</span>         <span style="color: #008000;">//</span><span style="color: #008000;">blahblahblah</span>
<span style="color: #008080;">12</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">13</span> }</pre>
</div>
<span class="cnblogs_code_collapse">像这样</span></div>
<p>直接在类里面存一个自己的实例，然后用一个静态方法来获取它。</p>
<p>这样别人没办法用这个类new对象，如果需要实例，那就用getInstance()来取。</p>
<p>&nbsp;</p>
<p>建议一则：</p>
<p>　　其他的方法尽量定为静态方法，不然是这样的：</p>
<div class="cnblogs_code">
<pre>Singleton.getInstance().<span style="color: #0000ff;">do</span>();</pre>
</div>
<p>　　脱裤子放屁，明明可以：</p>
<div class="cnblogs_code">
<pre>Singleton.<span style="color: #0000ff;">do</span>();</pre>
</div>
<p>&nbsp;</p>
<p>另外单例模式有线程安全的问题，等以后碰到这个问题再说吧。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f01c3cfd-6b02-4a7d-a96d-584752ff1ee7')"><img id="code_img_closed_f01c3cfd-6b02-4a7d-a96d-584752ff1ee7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f01c3cfd-6b02-4a7d-a96d-584752ff1ee7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f01c3cfd-6b02-4a7d-a96d-584752ff1ee7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f01c3cfd-6b02-4a7d-a96d-584752ff1ee7" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Singleton {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> Singleton singleton = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> Singleton() {}
</span><span style="color: #008080;"> 5</span>     
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Singleton getInstance() {
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">if</span> (singleton == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;"> 8</span>             singleton = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Singleton();
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">10</span>         
<span style="color: #008080;">11</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> singleton;
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">13</span>     
<span style="color: #008080;">14</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> doSomething() {
</span><span style="color: #008080;">15</span>         <span style="color: #008000;">//</span><span style="color: #008000;">blahblahblah</span>
<span style="color: #008080;">16</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">17</span> }</pre>
</div>
<span class="cnblogs_code_collapse">Synchronized</span></div>
<p>一个线程刚判断完还没来得及new对象，另一个线程也开始判断而且通过了，就出现了两个对象。</p>
<p>解决方法见折叠标题，不过没验证过，将来再说啦。</p>

<div align=right><a href="https://github.com/mlxy"><font size=1>——本文由博客园搬家工具SRBCnblogs转换而成</font></a></div>