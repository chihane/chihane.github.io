---
layout: post
title: 基于Demo解析缓存工具DiskLruCache
date: 2015-05-20 07:07:00
categories: cnblogs
---

<p><span style="line-height: 1.5;">https://github.com/mlxy/DiskLruCacheTest</span></p>
<p>&nbsp;</p>
<p>首先是DiskLruCache(下称DLC)的源码，就一个文件，随便扔在哪用就行。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('82a9f396-f43e-4280-a251-6ab94f10e4df')"><img id="code_img_closed_82a9f396-f43e-4280-a251-6ab94f10e4df" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_82a9f396-f43e-4280-a251-6ab94f10e4df" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('82a9f396-f43e-4280-a251-6ab94f10e4df',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_82a9f396-f43e-4280-a251-6ab94f10e4df" class="cnblogs_code_hide">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      </span><span style="color: #008000; text-decoration: underline;">http://www.apache.org/licenses/LICENSE-2.0</span><span style="color: #008000;">
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 </span><span style="color: #008000;">*/</span>

<span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.BufferedInputStream;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.BufferedWriter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.Closeable;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.EOFException;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileInputStream;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileNotFoundException;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileOutputStream;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileWriter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FilterOutputStream;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.IOException;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.InputStream;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.InputStreamReader;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.OutputStream;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.OutputStreamWriter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.Reader;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.StringWriter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.Writer;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Array;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.nio.charset.Charset;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Arrays;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Iterator;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.LinkedHashMap;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Map;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.Callable;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ExecutorService;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.LinkedBlockingQueue;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadPoolExecutor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.TimeUnit;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 ******************************************************************************
 * Taken from the JB source code, can be found in:
 * libcore/luni/src/main/java/libcore/io/DiskLruCache.java
 * or direct link:
 * </span><span style="color: #008000; text-decoration: underline;">https://android.googlesource.com/platform/libcore/</span><span style="color: #008000;">+/android-4.1.1_r1/luni/src/main/java/libcore/io/DiskLruCache.java
 ******************************************************************************
 *
 * A cache that uses a bounded amount of space on a filesystem. Each cache
 * entry has a string key and a fixed number of values. Values are byte
 * sequences, accessible as streams or files. Each value must be between {</span><span style="color: #808080;">@code</span><span style="color: #008000;">
 * 0} and {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> Integer.MAX_VALUE} bytes in length.
 *
 * &lt;p&gt;The cache stores its data in a directory on the filesystem. This
 * directory must be exclusive to the cache; the cache may delete or overwrite
 * files from its directory. It is an error for multiple processes to use the
 * same cache directory at the same time.
 *
 * &lt;p&gt;This cache limits the number of bytes that it will store on the
 * filesystem. When the number of stored bytes exceeds the limit, the cache will
 * remove entries in the background until the limit is satisfied. The limit is
 * not strict: the cache may temporarily exceed it while waiting for files to be
 * deleted. The limit does not include filesystem overhead or the cache
 * journal so space-sensitive applications should set a conservative limit.
 *
 * &lt;p&gt;Clients call {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #edit} to create or update the values of an entry. An
 * entry may have only one editor at one time; if a value is not available to be
 * edited then {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #edit} will return null.
 * &lt;ul&gt;
 *     &lt;li&gt;When an entry is being &lt;strong&gt;created&lt;/strong&gt; it is necessary to
 *         supply a full set of values; the empty value should be used as a
 *         placeholder if necessary.
 *     &lt;li&gt;When an entry is being &lt;strong&gt;edited&lt;/strong&gt;, it is not necessary
 *         to supply data for every value; values default to their previous
 *         value.
 * &lt;/ul&gt;
 * Every {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #edit} call must be matched by a call to {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> Editor#commit}
 * or {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> Editor#abort}. Committing is atomic: a read observes the full set
 * of values as they were before or after the commit, but never a mix of values.
 *
 * &lt;p&gt;Clients call {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #get} to read a snapshot of an entry. The read will
 * observe the value at the time that {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #get} was called. Updates and
 * removals after the call do not impact ongoing reads.
 *
 * &lt;p&gt;This class is tolerant of some I/O errors. If files are missing from the
 * filesystem, the corresponding entries will be dropped from the cache. If
 * an error occurs while writing a cache value, the edit will fail silently.
 * Callers should handle other problems by catching {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> IOException} and
 * responding appropriately.
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span> DiskLruCache <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Closeable {
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String JOURNAL_FILE = "journal"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String JOURNAL_FILE_TMP = "journal.tmp"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String MAGIC = "libcore.io.DiskLruCache"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String VERSION_1 = "1"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span> ANY_SEQUENCE_NUMBER = -1<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CLEAN = "CLEAN"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String DIRTY = "DIRTY"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String REMOVE = "REMOVE"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String READ = "READ"<span style="color: #000000;">;

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Charset UTF_8 = Charset.forName("UTF-8"<span style="color: #000000;">);
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> IO_BUFFER_SIZE = 8 * 1024<span style="color: #000000;">;

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     * This cache uses a journal file named "journal". A typical journal file
     * looks like this:
     *     libcore.io.DiskLruCache
     *     1
     *     100
     *     2
     *
     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
     *     READ 335c4c6028171cfddfbaae1a9c313c52
     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
     *
     * The first five lines of the journal form its header. They are the
     * constant string "libcore.io.DiskLruCache", the disk cache's version,
     * the application's version, the value count, and a blank line.
     *
     * Each of the subsequent lines in the file is a record of the state of a
     * cache entry. Each line contains space-separated values: a state, a key,
     * and optional state-specific values.
     *   o DIRTY lines track that an entry is actively being created or updated.
     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
     *     temporary files may need to be deleted.
     *   o CLEAN lines track a cache entry that has been successfully published
     *     and may be read. A publish line is followed by the lengths of each of
     *     its values.
     *   o READ lines track accesses for LRU.
     *   o REMOVE lines track entries that have been deleted.
     *
     * The journal file is appended to as cache operations occur. The journal may
     * occasionally be compacted by dropping redundant lines. A temporary file named
     * "journal.tmp" will be used during compaction; that file should be deleted if
     * it exists when the cache is opened.
     </span><span style="color: #008000;">*/</span>

    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> File directory;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> File journalFile;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> File journalFileTmp;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> appVersion;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> maxSize;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> valueCount;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">long</span> size = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Writer journalWriter;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> LinkedHashMap&lt;String, Entry&gt;<span style="color: #000000;"> lruEntries
            </span>= <span style="color: #0000ff;">new</span> LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> redundantOpCount;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * To differentiate between old and current snapshots, each entry is given
     * a sequence number each time an edit is committed. A snapshot is stale if
     * its sequence number is not equal to its entry's sequence number.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">long</span> nextSequenceNumber = 0<span style="color: #000000;">;

    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> From java.util.Arrays </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> originalLength = original.length; <span style="color: #008000;">//</span><span style="color: #008000;"> For exception priority compatibility.</span>
        <span style="color: #0000ff;">if</span> (start &gt;<span style="color: #000000;"> end) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalArgumentException();
        }
        </span><span style="color: #0000ff;">if</span> (start &lt; 0 || start &gt;<span style="color: #000000;"> originalLength) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayIndexOutOfBoundsException();
        }
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> resultLength = end -<span style="color: #000000;"> start;
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> copyLength = Math.min(resultLength, originalLength -<span style="color: #000000;"> start);
        </span><span style="color: #0000ff;">final</span> T[] result =<span style="color: #000000;"> (T[]) Array
                .newInstance(original.getClass().getComponentType(), resultLength);
        System.arraycopy(original, start, result, </span>0<span style="color: #000000;">, copyLength);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns the remainder of 'reader' as a string, closing it when done.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> String readFully(Reader reader) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            StringWriter writer </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringWriter();
            </span><span style="color: #0000ff;">char</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">char</span>[1024<span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
            </span><span style="color: #0000ff;">while</span> ((count = reader.read(buffer)) != -1<span style="color: #000000;">) {
                writer.write(buffer, </span>0<span style="color: #000000;">, count);
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> writer.toString();
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            reader.close();
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns the ASCII characters up to but not including the next "\r\n", or
     * "\n".
     *
     * </span><span style="color: #808080;">@throws</span><span style="color: #008000;"> java.io.EOFException if the stream is exhausted before the next newline
     *     character.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> String readAsciiLine(InputStream in) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO: support UTF-8 here instead</span>
<span style="color: #000000;">
        StringBuilder result </span>= <span style="color: #0000ff;">new</span> StringBuilder(80<span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> c =<span style="color: #000000;"> in.read();
            </span><span style="color: #0000ff;">if</span> (c == -1<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> EOFException();
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == '\n'<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }

            result.append((</span><span style="color: #0000ff;">char</span><span style="color: #000000;">) c);
        }
        </span><span style="color: #0000ff;">int</span> length =<span style="color: #000000;"> result.length();
        </span><span style="color: #0000ff;">if</span> (length &gt; 0 &amp;&amp; result.charAt(length - 1) == '\r'<span style="color: #000000;">) {
            result.setLength(length </span>- 1<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result.toString();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Closes 'closeable', ignoring any checked exceptions. Does nothing if 'closeable' is null.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> closeQuietly(Closeable closeable) {
        </span><span style="color: #0000ff;">if</span> (closeable != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                closeable.close();
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (RuntimeException rethrown) {
                </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> rethrown;
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception ignored) {
            }
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Recursively delete everything in {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> dir}.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">//</span><span style="color: #008000;"> TODO: this should specify paths as Strings rather than as Files</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> deleteContents(File dir) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        File[] files </span>=<span style="color: #000000;"> dir.listFiles();
        </span><span style="color: #0000ff;">if</span> (files == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("not a directory: " +<span style="color: #000000;"> dir);
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (File file : files) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (file.isDirectory()) {
                deleteContents(file);
            }
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">file.delete()) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IOException("failed to delete file: " +<span style="color: #000000;"> file);
            }
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> This cache uses a single background thread to evict entries. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> ExecutorService executorService = <span style="color: #0000ff;">new</span> ThreadPoolExecutor(0, 1<span style="color: #000000;">,
            </span>60L, TimeUnit.SECONDS, <span style="color: #0000ff;">new</span> LinkedBlockingQueue&lt;Runnable&gt;<span style="color: #000000;">());
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Callable&lt;Void&gt; cleanupCallable = <span style="color: #0000ff;">new</span> Callable&lt;Void&gt;<span style="color: #000000;">() {
        @Override </span><span style="color: #0000ff;">public</span> Void call() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
            </span><span style="color: #0000ff;">synchronized</span> (DiskLruCache.<span style="color: #0000ff;">this</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (journalWriter == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> closed</span>
<span style="color: #000000;">                }
                trimToSize();
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (journalRebuildRequired()) {
                    rebuildJournal();
                    redundantOpCount </span>= 0<span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
    };

    </span><span style="color: #0000ff;">private</span> DiskLruCache(File directory, <span style="color: #0000ff;">int</span> appVersion, <span style="color: #0000ff;">int</span> valueCount, <span style="color: #0000ff;">long</span><span style="color: #000000;"> maxSize) {
        </span><span style="color: #0000ff;">this</span>.directory =<span style="color: #000000;"> directory;
        </span><span style="color: #0000ff;">this</span>.appVersion =<span style="color: #000000;"> appVersion;
        </span><span style="color: #0000ff;">this</span>.journalFile = <span style="color: #0000ff;">new</span><span style="color: #000000;"> File(directory, JOURNAL_FILE);
        </span><span style="color: #0000ff;">this</span>.journalFileTmp = <span style="color: #0000ff;">new</span><span style="color: #000000;"> File(directory, JOURNAL_FILE_TMP);
        </span><span style="color: #0000ff;">this</span>.valueCount =<span style="color: #000000;"> valueCount;
        </span><span style="color: #0000ff;">this</span>.maxSize =<span style="color: #000000;"> maxSize;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Opens the cache in {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> directory}, creating a cache if none exists
     * there.
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> directory a writable directory
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> appVersion
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> valueCount the number of values per cache entry. Must be positive.
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> maxSize the maximum number of bytes this cache should use to store
     * </span><span style="color: #808080;">@throws</span><span style="color: #008000;"> java.io.IOException if reading or writing the cache directory fails
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> DiskLruCache open(File directory, <span style="color: #0000ff;">int</span> appVersion, <span style="color: #0000ff;">int</span> valueCount, <span style="color: #0000ff;">long</span><span style="color: #000000;"> maxSize)
            </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">if</span> (maxSize &lt;= 0<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("maxSize &lt;= 0"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">if</span> (valueCount &lt;= 0<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("valueCount &lt;= 0"<span style="color: #000000;">);
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> prefer to pick up where we left off</span>
        DiskLruCache cache = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DiskLruCache(directory, appVersion, valueCount, maxSize);
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (cache.journalFile.exists()) {
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                cache.readJournal();
                cache.processJournal();
                cache.journalWriter </span>= <span style="color: #0000ff;">new</span> BufferedWriter(<span style="color: #0000ff;">new</span> FileWriter(cache.journalFile, <span style="color: #0000ff;">true</span><span style="color: #000000;">),
                        IO_BUFFER_SIZE);
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cache;
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException journalIsCorrupt) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                System.logW("DiskLruCache " + directory + " is corrupt: "
</span><span style="color: #008000;">//</span><span style="color: #008000;">                        + journalIsCorrupt.getMessage() + ", removing");</span>
<span style="color: #000000;">                cache.delete();
            }
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> create a new empty cache</span>
<span style="color: #000000;">        directory.mkdirs();
        cache </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> DiskLruCache(directory, appVersion, valueCount, maxSize);
        cache.rebuildJournal();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cache;
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> readJournal() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        InputStream in </span>= <span style="color: #0000ff;">new</span> BufferedInputStream(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(journalFile), IO_BUFFER_SIZE);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            String magic </span>=<span style="color: #000000;"> readAsciiLine(in);
            String version </span>=<span style="color: #000000;"> readAsciiLine(in);
            String appVersionString </span>=<span style="color: #000000;"> readAsciiLine(in);
            String valueCountString </span>=<span style="color: #000000;"> readAsciiLine(in);
            String blank </span>=<span style="color: #000000;"> readAsciiLine(in);
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">MAGIC.equals(magic)
                    </span>|| !<span style="color: #000000;">VERSION_1.equals(version)
                    </span>|| !<span style="color: #000000;">Integer.toString(appVersion).equals(appVersionString)
                    </span>|| !<span style="color: #000000;">Integer.toString(valueCount).equals(valueCountString)
                    </span>|| !""<span style="color: #000000;">.equals(blank)) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IOException("unexpected journal header: ["
                        + magic + ", " + version + ", " + valueCountString + ", " + blank + "]"<span style="color: #000000;">);
            }

            </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    readJournalLine(readAsciiLine(in));
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (EOFException endOfJournal) {
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            closeQuietly(in);
        }
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> readJournalLine(String line) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        String[] parts </span>= line.split(" "<span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (parts.length &lt; 2<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IOException("unexpected journal line: " +<span style="color: #000000;"> line);
        }

        String key </span>= parts[1<span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (parts[0].equals(REMOVE) &amp;&amp; parts.length == 2<span style="color: #000000;">) {
            lruEntries.remove(key);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        Entry entry </span>=<span style="color: #000000;"> lruEntries.get(key);
        </span><span style="color: #0000ff;">if</span> (entry == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            entry </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Entry(key);
            lruEntries.put(key, entry);
        }

        </span><span style="color: #0000ff;">if</span> (parts[0].equals(CLEAN) &amp;&amp; parts.length == 2 +<span style="color: #000000;"> valueCount) {
            entry.readable </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            entry.currentEditor </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            entry.setLengths(copyOfRange(parts, </span>2<span style="color: #000000;">, parts.length));
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (parts[0].equals(DIRTY) &amp;&amp; parts.length == 2<span style="color: #000000;">) {
            entry.currentEditor </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Editor(entry);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (parts[0].equals(READ) &amp;&amp; parts.length == 2<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> this work was already done by calling lruEntries.get()</span>
        } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IOException("unexpected journal line: " +<span style="color: #000000;"> line);
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Computes the initial size and collects garbage as a part of opening the
     * cache. Dirty entries are assumed to be inconsistent and will be deleted.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> processJournal() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        deleteIfExists(journalFileTmp);
        </span><span style="color: #0000ff;">for</span> (Iterator&lt;Entry&gt; i =<span style="color: #000000;"> lruEntries.values().iterator(); i.hasNext(); ) {
            Entry entry </span>=<span style="color: #000000;"> i.next();
            </span><span style="color: #0000ff;">if</span> (entry.currentEditor == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> t = 0; t &lt; valueCount; t++<span style="color: #000000;">) {
                    size </span>+=<span style="color: #000000;"> entry.lengths[t];
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                entry.currentEditor </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> t = 0; t &lt; valueCount; t++<span style="color: #000000;">) {
                    deleteIfExists(entry.getCleanFile(t));
                    deleteIfExists(entry.getDirtyFile(t));
                }
                i.remove();
            }
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Creates a new journal that omits redundant information. This replaces the
     * current journal if it exists.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span> rebuildJournal() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">if</span> (journalWriter != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            journalWriter.close();
        }

        Writer writer </span>= <span style="color: #0000ff;">new</span> BufferedWriter(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileWriter(journalFileTmp), IO_BUFFER_SIZE);
        writer.write(MAGIC);
        writer.write(</span>"\n"<span style="color: #000000;">);
        writer.write(VERSION_1);
        writer.write(</span>"\n"<span style="color: #000000;">);
        writer.write(Integer.toString(appVersion));
        writer.write(</span>"\n"<span style="color: #000000;">);
        writer.write(Integer.toString(valueCount));
        writer.write(</span>"\n"<span style="color: #000000;">);
        writer.write(</span>"\n"<span style="color: #000000;">);

        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Entry entry : lruEntries.values()) {
            </span><span style="color: #0000ff;">if</span> (entry.currentEditor != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                writer.write(DIRTY </span>+ ' ' + entry.key + '\n'<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                writer.write(CLEAN </span>+ ' ' + entry.key + entry.getLengths() + '\n'<span style="color: #000000;">);
            }
        }

        writer.close();
        journalFileTmp.renameTo(journalFile);
        journalWriter </span>= <span style="color: #0000ff;">new</span> BufferedWriter(<span style="color: #0000ff;">new</span> FileWriter(journalFile, <span style="color: #0000ff;">true</span><span style="color: #000000;">), IO_BUFFER_SIZE);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> deleteIfExists(File file) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        try {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            Libcore.os.remove(file.getPath());
</span><span style="color: #008000;">//</span><span style="color: #008000;">        } catch (ErrnoException errnoException) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            if (errnoException.errno != OsConstants.ENOENT) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                throw errnoException.rethrowAsIOException();
</span><span style="color: #008000;">//</span><span style="color: #008000;">            }
</span><span style="color: #008000;">//</span><span style="color: #008000;">        }</span>
        <span style="color: #0000ff;">if</span> (file.exists() &amp;&amp; !<span style="color: #000000;">file.delete()) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IOException();
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns a snapshot of the entry named {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> key}, or null if it doesn't
     * exist is not currently readable. If a value is returned, it is moved to
     * the head of the LRU queue.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> Snapshot get(String key) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        checkNotClosed();
        validateKey(key);
        Entry entry </span>=<span style="color: #000000;"> lruEntries.get(key);
        </span><span style="color: #0000ff;">if</span> (entry == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">entry.readable) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">
         * Open all streams eagerly to guarantee that we see a single published
         * snapshot. If we opened streams lazily then the streams could come
         * from different edits.
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        InputStream[] ins </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> InputStream[valueCount];
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; valueCount; i++<span style="color: #000000;">) {
                ins[i] </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(entry.getCleanFile(i));
            }
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (FileNotFoundException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> a file must have been deleted manually!</span>
            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        redundantOpCount</span>++<span style="color: #000000;">;
        journalWriter.append(READ </span>+ ' ' + key + '\n'<span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (journalRebuildRequired()) {
            executorService.submit(cleanupCallable);
        }

        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Snapshot(key, entry.sequenceNumber, ins);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns an editor for the entry named {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> key}, or null if another
     * edit is in progress.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Editor edit(String key) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> edit(key, ANY_SEQUENCE_NUMBER);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">synchronized</span> Editor edit(String key, <span style="color: #0000ff;">long</span> expectedSequenceNumber) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        checkNotClosed();
        validateKey(key);
        Entry entry </span>=<span style="color: #000000;"> lruEntries.get(key);
        </span><span style="color: #0000ff;">if</span> (expectedSequenceNumber !=<span style="color: #000000;"> ANY_SEQUENCE_NUMBER
                </span>&amp;&amp; (entry == <span style="color: #0000ff;">null</span> || entry.sequenceNumber !=<span style="color: #000000;"> expectedSequenceNumber)) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> snapshot is stale</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">if</span> (entry == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            entry </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Entry(key);
            lruEntries.put(key, entry);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (entry.currentEditor != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> another edit is in progress</span>
<span style="color: #000000;">        }

        Editor editor </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Editor(entry);
        entry.currentEditor </span>=<span style="color: #000000;"> editor;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> flush the journal before creating files to prevent file leaks</span>
        journalWriter.write(DIRTY + ' ' + key + '\n'<span style="color: #000000;">);
        journalWriter.flush();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> editor;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns the directory where this cache stores its data.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> File getDirectory() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> directory;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns the maximum number of bytes that this cache should use to store
     * its data.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> maxSize() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> maxSize;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns the number of bytes currently being used to store the values in
     * this cache. This may be greater than the max size if a background
     * deletion is pending.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> size() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> size;
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span> completeEdit(Editor editor, <span style="color: #0000ff;">boolean</span> success) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        Entry entry </span>=<span style="color: #000000;"> editor.entry;
        </span><span style="color: #0000ff;">if</span> (entry.currentEditor !=<span style="color: #000000;"> editor) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalStateException();
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> if this edit is creating the entry for the first time, every index must have a value</span>
        <span style="color: #0000ff;">if</span> (success &amp;&amp; !<span style="color: #000000;">entry.readable) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; valueCount; i++<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">entry.getDirtyFile(i).exists()) {
                    editor.abort();
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("edit didn't create file " +<span style="color: #000000;"> i);
                }
            }
        }

        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; valueCount; i++<span style="color: #000000;">) {
            File dirty </span>=<span style="color: #000000;"> entry.getDirtyFile(i);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (success) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (dirty.exists()) {
                    File clean </span>=<span style="color: #000000;"> entry.getCleanFile(i);
                    dirty.renameTo(clean);
                    </span><span style="color: #0000ff;">long</span> oldLength =<span style="color: #000000;"> entry.lengths[i];
                    </span><span style="color: #0000ff;">long</span> newLength =<span style="color: #000000;"> clean.length();
                    entry.lengths[i] </span>=<span style="color: #000000;"> newLength;
                    size </span>= size - oldLength +<span style="color: #000000;"> newLength;
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                deleteIfExists(dirty);
            }
        }

        redundantOpCount</span>++<span style="color: #000000;">;
        entry.currentEditor </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (entry.readable |<span style="color: #000000;"> success) {
            entry.readable </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            journalWriter.write(CLEAN </span>+ ' ' + entry.key + entry.getLengths() + '\n'<span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (success) {
                entry.sequenceNumber </span>= nextSequenceNumber++<span style="color: #000000;">;
            }
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            lruEntries.remove(entry.key);
            journalWriter.write(REMOVE </span>+ ' ' + entry.key + '\n'<span style="color: #000000;">);
        }

        </span><span style="color: #0000ff;">if</span> (size &gt; maxSize ||<span style="color: #000000;"> journalRebuildRequired()) {
            executorService.submit(cleanupCallable);
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * We only rebuild the journal when it will halve the size of the journal
     * and eliminate at least 2000 ops.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> journalRebuildRequired() {
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> REDUNDANT_OP_COMPACT_THRESHOLD = 2000<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> redundantOpCount &gt;=<span style="color: #000000;"> REDUNDANT_OP_COMPACT_THRESHOLD
                </span>&amp;&amp; redundantOpCount &gt;=<span style="color: #000000;"> lruEntries.size();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Drops the entry for {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> key} if it exists and can be removed. Entries
     * actively being edited cannot be removed.
     *
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> true if an entry was removed.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">boolean</span> remove(String key) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        checkNotClosed();
        validateKey(key);
        Entry entry </span>=<span style="color: #000000;"> lruEntries.get(key);
        </span><span style="color: #0000ff;">if</span> (entry == <span style="color: #0000ff;">null</span> || entry.currentEditor != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }

        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; valueCount; i++<span style="color: #000000;">) {
            File file </span>=<span style="color: #000000;"> entry.getCleanFile(i);
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">file.delete()) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IOException("failed to delete " +<span style="color: #000000;"> file);
            }
            size </span>-=<span style="color: #000000;"> entry.lengths[i];
            entry.lengths[i] </span>= 0<span style="color: #000000;">;
        }

        redundantOpCount</span>++<span style="color: #000000;">;
        journalWriter.append(REMOVE </span>+ ' ' + key + '\n'<span style="color: #000000;">);
        lruEntries.remove(key);

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (journalRebuildRequired()) {
            executorService.submit(cleanupCallable);
        }

        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Returns true if this cache has been closed.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isClosed() {
        </span><span style="color: #0000ff;">return</span> journalWriter == <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> checkNotClosed() {
        </span><span style="color: #0000ff;">if</span> (journalWriter == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("cache is closed"<span style="color: #000000;">);
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Force buffered operations to the filesystem.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span> flush() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        checkNotClosed();
        trimToSize();
        journalWriter.flush();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Closes this cache. Stored values will remain on the filesystem.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span> close() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">if</span> (journalWriter == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> already closed</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">for</span> (Entry entry : <span style="color: #0000ff;">new</span> ArrayList&lt;Entry&gt;<span style="color: #000000;">(lruEntries.values())) {
            </span><span style="color: #0000ff;">if</span> (entry.currentEditor != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                entry.currentEditor.abort();
            }
        }
        trimToSize();
        journalWriter.close();
        journalWriter </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> trimToSize() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">while</span> (size &gt;<span style="color: #000000;"> maxSize) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.eldest();</span>
            <span style="color: #0000ff;">final</span> Map.Entry&lt;String, Entry&gt; toEvict =<span style="color: #000000;"> lruEntries.entrySet().iterator().next();
            remove(toEvict.getKey());
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Closes the cache and deletes all of its stored values. This will delete
     * all files in the cache directory including files that weren't created by
     * the cache.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> delete() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        close();
        deleteContents(directory);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> validateKey(String key) {
        </span><span style="color: #0000ff;">if</span> (key.contains(" ") || key.contains("\n") || key.contains("\r"<span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalArgumentException(
                    </span>"keys must not contain spaces or newlines: \"" + key + "\""<span style="color: #000000;">);
        }
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> String inputStreamToString(InputStream in) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #0000ff;">return</span> readFully(<span style="color: #0000ff;">new</span><span style="color: #000000;"> InputStreamReader(in, UTF_8));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * A snapshot of the values for an entry.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span> Snapshot <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Closeable {
        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String key;
        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> sequenceNumber;
        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> InputStream[] ins;

        </span><span style="color: #0000ff;">private</span> Snapshot(String key, <span style="color: #0000ff;">long</span><span style="color: #000000;"> sequenceNumber, InputStream[] ins) {
            </span><span style="color: #0000ff;">this</span>.key =<span style="color: #000000;"> key;
            </span><span style="color: #0000ff;">this</span>.sequenceNumber =<span style="color: #000000;"> sequenceNumber;
            </span><span style="color: #0000ff;">this</span>.ins =<span style="color: #000000;"> ins;
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Returns an editor for this snapshot's entry, or null if either the
         * entry has changed since this snapshot was created or if another edit
         * is in progress.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> Editor edit() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">return</span> DiskLruCache.<span style="color: #0000ff;">this</span><span style="color: #000000;">.edit(key, sequenceNumber);
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Returns the unbuffered stream with the value for {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> index}.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> InputStream getInputStream(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ins[index];
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Returns the string value for {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> index}.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> String getString(<span style="color: #0000ff;">int</span> index) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> inputStreamToString(getInputStream(index));
        }

        @Override </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> close() {
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (InputStream in : ins) {
                closeQuietly(in);
            }
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * Edits the values for an entry.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Editor {
        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Entry entry;
        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> hasErrors;

        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Editor(Entry entry) {
            </span><span style="color: #0000ff;">this</span>.entry =<span style="color: #000000;"> entry;
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Returns an unbuffered input stream to read the last committed value,
         * or null if no value has been committed.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> InputStream newInputStream(<span style="color: #0000ff;">int</span> index) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">synchronized</span> (DiskLruCache.<span style="color: #0000ff;">this</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (entry.currentEditor != <span style="color: #0000ff;">this</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalStateException();
                }
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">entry.readable) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(entry.getCleanFile(index));
            }
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Returns the last committed value as a string, or null if no value
         * has been committed.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> String getString(<span style="color: #0000ff;">int</span> index) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            InputStream in </span>=<span style="color: #000000;"> newInputStream(index);
            </span><span style="color: #0000ff;">return</span> in != <span style="color: #0000ff;">null</span> ? inputStreamToString(in) : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Returns a new unbuffered output stream to write the value at
         * {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> index}. If the underlying output stream encounters errors
         * when writing to the filesystem, this edit will be aborted when
         * {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #commit} is called. The returned output stream does not throw
         * IOExceptions.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> OutputStream newOutputStream(<span style="color: #0000ff;">int</span> index) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">synchronized</span> (DiskLruCache.<span style="color: #0000ff;">this</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (entry.currentEditor != <span style="color: #0000ff;">this</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalStateException();
                }
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> FaultHidingOutputStream(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(entry.getDirtyFile(index)));
            }
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Sets the value at {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> index} to {</span><span style="color: #808080;">@code</span><span style="color: #008000;"> value}.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> set(<span style="color: #0000ff;">int</span> index, String value) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            Writer writer </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                writer </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> OutputStreamWriter(newOutputStream(index), UTF_8);
                writer.write(value);
            } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
                closeQuietly(writer);
            }
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Commits this edit so it is visible to readers.  This releases the
         * edit lock so another edit may be started on the same key.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> commit() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (hasErrors) {
                completeEdit(</span><span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
                remove(entry.key); </span><span style="color: #008000;">//</span><span style="color: #008000;"> the previous entry is stale</span>
            } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                completeEdit(</span><span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
            }
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Aborts this edit. This releases the edit lock so another edit may be
         * started on the same key.
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> abort() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            completeEdit(</span><span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        }

        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">class</span> FaultHidingOutputStream <span style="color: #0000ff;">extends</span><span style="color: #000000;"> FilterOutputStream {
            </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> FaultHidingOutputStream(OutputStream out) {
                </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(out);
            }

            @Override </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> write(<span style="color: #0000ff;">int</span><span style="color: #000000;"> oneByte) {
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    out.write(oneByte);
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                    hasErrors </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }

            @Override </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> write(<span style="color: #0000ff;">byte</span>[] buffer, <span style="color: #0000ff;">int</span> offset, <span style="color: #0000ff;">int</span><span style="color: #000000;"> length) {
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    out.write(buffer, offset, length);
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                    hasErrors </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }

            @Override </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> close() {
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    out.close();
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                    hasErrors </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }

            @Override </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> flush() {
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    out.flush();
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                    hasErrors </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
        }
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Entry {
        </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String key;

        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> Lengths of this entry's files. </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span><span style="color: #000000;">[] lengths;

        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> True if this entry has ever been published </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> readable;

        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> The ongoing edit or null if this entry is not being edited. </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">private</span><span style="color: #000000;"> Editor currentEditor;

        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> The sequence number of the most recently committed edit to this entry. </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> sequenceNumber;

        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Entry(String key) {
            </span><span style="color: #0000ff;">this</span>.key =<span style="color: #000000;"> key;
            </span><span style="color: #0000ff;">this</span>.lengths = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">long</span><span style="color: #000000;">[valueCount];
        }

        </span><span style="color: #0000ff;">public</span> String getLengths() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            StringBuilder result </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">long</span><span style="color: #000000;"> size : lengths) {
                result.append(</span>' '<span style="color: #000000;">).append(size);
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result.toString();
        }

        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * Set lengths using decimal numbers like "10123".
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> setLengths(String[] strings) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">if</span> (strings.length !=<span style="color: #000000;"> valueCount) {
                </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> invalidLengths(strings);
            }

            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; strings.length; i++<span style="color: #000000;">) {
                    lengths[i] </span>=<span style="color: #000000;"> Long.parseLong(strings[i]);
                }
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (NumberFormatException e) {
                </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> invalidLengths(strings);
            }
        }

        </span><span style="color: #0000ff;">private</span> IOException invalidLengths(String[] strings) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IOException("unexpected journal line: " +<span style="color: #000000;"> Arrays.toString(strings));
        }

        </span><span style="color: #0000ff;">public</span> File getCleanFile(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> File(directory, key + "." +<span style="color: #000000;"> i);
        }

        </span><span style="color: #0000ff;">public</span> File getDirtyFile(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> File(directory, key + "." + i + ".tmp"<span style="color: #000000;">);
        }
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">DiskLruCache</span></div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>&middot;DiskLruCacheHelper类</strong></span></p>
<p>然后根据这个小Demo的需要做一下简单封装，写了个DiskLruCacheHelper类。</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><span style="font-size: 15px;"><strong>初始化</strong></span></span></p>
<p>DLC的构造函数是私有的，需要用静态方法初始化。</p>
<div class="cnblogs_code">
<pre> DiskLruCache.open(File directory, <span style="color: #0000ff;">int</span> appVersion, <span style="color: #0000ff;">int</span> valueCount, <span style="color: #0000ff;">long</span> maxSize)</pre>
</div>
<p>&nbsp;</p>
<p>第一个参数directory是缓存路径，可以直接用应用的缓存路径，这样在应用卸载的时候缓存也会自动清除。</p>
<p>写一个简单的判断，插了SD卡或者SD卡不能移除就用SD卡缓存目录，否则用系统缓存目录。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> DiskLruCache mCache;
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
</span><span style="color: #008080;">3</span>         || !<span style="color: #000000;">Environment.isExternalStorageRemovable()) {
</span><span style="color: #008080;">4</span>     mCache = DiskLruCache.open(context.getExternalCacheDir(), 0, 1, 10 * 1024 * 1024<span style="color: #000000;">);
</span><span style="color: #008080;">5</span> } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">6</span>     mCache = DiskLruCache.open(context.getCacheDir(), 0, 1, 10 * 1024 * 1024<span style="color: #000000;">);
</span><span style="color: #008080;">7</span> }</pre>
</div>
<p>&nbsp;</p>
<p>第二个参数appVersion是应用版本，我这里因为只是个Demo就直接给了0，实际应用中可以用versionCode。</p>
<p>顺手查了个代码，一并放上来得了。</p>
<div class="cnblogs_code">
<pre>Context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionCode</pre>
</div>
<p>在版本号发生变动的时候DLC会自动删除所有缓存。</p>
<p>&nbsp;</p>
<p>第三个参数valueCount决定了一个key可以对应多少个缓存文件，正常情况下给1就行。</p>
<p>&hellip;&hellip;</p>
<p>但是本着负责任的态度我决定去试试改成2会怎么样。</p>
<p>&hellip;&hellip;</p>
<p>嗯它报错了。</p>
<p>&hellip;&hellip;</p>
<p>&hellip;&hellip;</p>
<p>嗯我决定不整这些没用的。</p>
<p>我大概能猜到结果是什么样的，但是我决定不把没根据的事拿上来说。</p>
<p>&nbsp;</p>
<p>第四个参数maxSize是缓存数据的总上限，单位是字节。好懂，不用多说。</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><span style="font-size: 15px;"><strong>保存缓存</strong></span></span></p>
<p>DLC和SharedPreferences类似，也需要用一个Editor来编辑内容。</p>
<p>&nbsp;</p>
<p>Editor使用</p>
<div class="cnblogs_code">
<pre>DiskLruCache.edit(String key)</pre>
</div>
<p>来初始化，key是缓存的键名，也就是缓存文件的文件名。</p>
<p>我这个Demo缓存的是网络图片，于是用了图片URL的MD5作为键名，MD5的问题等会另开一篇说。</p>
<p>&nbsp;</p>
<p>之后就可以用</p>
<div class="cnblogs_code">
<pre>Editor.newOutputStream(<span style="color: #0000ff;">int</span> index)</pre>
</div>
<p>打开一个输出流，之后想怎么写就怎么写。</p>
<p>参数index是和初始化DLC时的valueCount有关，上面填了1，那这里直接给0就可以。</p>
<p>如果上面不是1的话这里怎么填电视机前聪明的小朋友们应该也能想到。</p>
<p>&nbsp;</p>
<p>和SharedPreferences一样，Editor在编辑完数据后也需要使用commit()来提交修改。相反如果调用abort()就可以放弃修改。</p>
<p>不commit的话虽然也有缓存，但是每次还是会从网上重新下载，后面讲日志的时候细说。</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><strong><span style="font-size: 15px;">读取缓存</span></strong></span></p>
<p>读取起来就很简单了，使用</p>
<div class="cnblogs_code">
<pre>DiskLruCache.get(String key)</pre>
</div>
<p>方法拿到Snapshot对象，再用</p>
<div class="cnblogs_code">
<pre>Snapshot.getInputStream(<span style="color: #0000ff;">int</span> index)</pre>
</div>
<p>方法拿到输入流就可以随便读了。</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><span style="font-size: 15px;"><strong>写出日志</strong></span></span></p>
<p>最后是DiskLruCache.flush()方法，用过IO流的话应该知道它的作用，在这里也类似，是用于将修改同步到日志文件中的。</p>
<p>在Activity的onPause()方法中调一次就行，不需要每次写出都执行一遍，影响执行效率。</p>
<p>另外和IO流中一样，这个方法有的时候会自动调用，所以在某些场景下好像一直不用也没问题，但是保不齐什么时候就出个大岔子是不是。</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline; font-size: 15px;"><strong>没用到而且不说也行的东西</strong></span></p>
<p>DiskLruCache.size()：一看就懂，缓存的总大小。可以用来给用户看。</p>
<p>DiskLruCache.remove(String key)：一看就懂，删除某个缓存，但是反正DLC能自动清理，干嘛要自己删呢。</p>
<p>DiskLruCache.delete()：一看不太懂，但是说了就懂，清除所有缓存，可以作为手动清理缓存功能给用户用。但是为什么不叫clear或者empty。</p>
<p>&nbsp;</p>
<p>于是放一下完整代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('79e891c2-c168-4cf0-9da5-0bb651fee5a6')"><img id="code_img_closed_79e891c2-c168-4cf0-9da5-0bb651fee5a6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_79e891c2-c168-4cf0-9da5-0bb651fee5a6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('79e891c2-c168-4cf0-9da5-0bb651fee5a6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_79e891c2-c168-4cf0-9da5-0bb651fee5a6" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> com.mlxy.disklrucachetest.util;
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> android.content.Context;
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> android.os.Environment;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> com.mlxy.disklrucachetest.disklrucache.DiskLruCache;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.BufferedInputStream;
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.BufferedOutputStream;
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.IOException;
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.InputStream;
</span><span style="color: #008080;">12</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.OutputStream;
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DiskLruCacheHelper {
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> DiskLruCache mCache;
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span>     <span style="color: #008000;">/**</span><span style="color: #008000;"> 打开DiskLruCache。 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">18</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> openCache(Context context) {
</span><span style="color: #008080;">19</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;">20</span>             <span style="color: #0000ff;">if</span><span style="color: #000000;"> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
</span><span style="color: #008080;">21</span>                     || !<span style="color: #000000;">Environment.isExternalStorageRemovable()) {
</span><span style="color: #008080;">22</span>                 mCache = DiskLruCache.open(context.getExternalCacheDir(), 0, 1, 10 * 1024 * 1024<span style="color: #000000;">);
</span><span style="color: #008080;">23</span>             } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">24</span>                 mCache = DiskLruCache.open(context.getCacheDir(), 0, 1, 10 * 1024 * 1024<span style="color: #000000;">);
</span><span style="color: #008080;">25</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">26</span>         } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
</span><span style="color: #008080;">27</span> <span style="color: #000000;">            e.printStackTrace();
</span><span style="color: #008080;">28</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">29</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">30</span> 
<span style="color: #008080;">31</span>     <span style="color: #008000;">/**</span><span style="color: #008000;"> 写出缓存。 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">32</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> dump(InputStream inputStream, String keyCache) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008080;">33</span>         <span style="color: #0000ff;">if</span> (mCache == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("Must call openCache() first!"<span style="color: #000000;">);
</span><span style="color: #008080;">34</span> 
<span style="color: #008080;">35</span>         DiskLruCache.Editor mEditor =<span style="color: #000000;"> mCache.edit(keyCache);
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span>         OutputStream outputStream = mEditor.newOutputStream(0<span style="color: #000000;">);
</span><span style="color: #008080;">38</span> 
<span style="color: #008080;">39</span>         BufferedInputStream bin = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BufferedInputStream(inputStream);
</span><span style="color: #008080;">40</span>         BufferedOutputStream bout = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BufferedOutputStream(outputStream);
</span><span style="color: #008080;">41</span> 
<span style="color: #008080;">42</span>         <span style="color: #0000ff;">byte</span>[] buf = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
</span><span style="color: #008080;">43</span>         <span style="color: #0000ff;">int</span><span style="color: #000000;"> len;
</span><span style="color: #008080;">44</span>         <span style="color: #0000ff;">while</span> ((len = bin.read(buf)) != -1<span style="color: #000000;">) {
</span><span style="color: #008080;">45</span>             bout.write(buf, 0<span style="color: #000000;">, len);
</span><span style="color: #008080;">46</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">47</span> 
<span style="color: #008080;">48</span> <span style="color: #000000;">        bout.close();
</span><span style="color: #008080;">49</span> <span style="color: #000000;">        outputStream.close();
</span><span style="color: #008080;">50</span> 
<span style="color: #008080;">51</span> <span style="color: #000000;">        mEditor.commit();
</span><span style="color: #008080;">52</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">53</span> 
<span style="color: #008080;">54</span>     <span style="color: #008000;">/**</span><span style="color: #008000;"> 读取缓存。 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">55</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> InputStream load(String keyCache) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008080;">56</span>         <span style="color: #0000ff;">if</span> (mCache == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("Must call openCache() first!"<span style="color: #000000;">);
</span><span style="color: #008080;">57</span> 
<span style="color: #008080;">58</span>         DiskLruCache.Snapshot snapshot =<span style="color: #000000;"> mCache.get(keyCache);
</span><span style="color: #008080;">59</span> 
<span style="color: #008080;">60</span>         <span style="color: #0000ff;">if</span> (snapshot == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">61</span>         <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> snapshot.getInputStream(0<span style="color: #000000;">);
</span><span style="color: #008080;">62</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">63</span> 
<span style="color: #008080;">64</span>     <span style="color: #008000;">/**</span><span style="color: #008000;"> 同步日志。 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">65</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> syncLog() {
</span><span style="color: #008080;">66</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;">67</span> <span style="color: #000000;">            mCache.flush();
</span><span style="color: #008080;">68</span>         } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
</span><span style="color: #008080;">69</span> <span style="color: #000000;">            e.printStackTrace();
</span><span style="color: #008080;">70</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">71</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">72</span> }</pre>
</div>
<span class="cnblogs_code_collapse">现在可以公开的情报</span></div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>&middot;关于日志</strong></span></p>
<p>缓存文件夹下除了自己起名的缓存文件之外还有一个叫journal的文件，内容像这样：</p>
<blockquote>
<p>libcore.io.DiskLruCache</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>&nbsp;</p>
<p>DIRTY 5d11e89e475c9f38ddf14eeb58c1affa</p>
<p>CLEAN 5d11e89e475c9f38ddf14eeb58c1affa 200635</p>
<p>READ&nbsp;5d11e89e475c9f38ddf14eeb58c1affa</p>
<p>DIRTY 5d11e89e475c9f38ddf14eeb58c1affa</p>
<p>REMOVE&nbsp;5d11e89e475c9f38ddf14eeb58c1affa</p>
</blockquote>
<p>前四行分别是DLC的包名、DLC的版本、应用的版本和valueCount，后面两个就是初始化DiskLruCache类时传入的两个对应的参数。</p>
<p>第五行像HTML一样是个空行，再下面就是操作日志了。</p>
<p>&nbsp;</p>
<p>再下面的记录分四种：</p>
<p>1. DIRTY：</p>
<p>在刚刚写入缓存没有commit也没有flush的时候DLC会写一条DIRTY记录，后面是缓存的键名。</p>
<p>DIRTY数据在下一次打开DLC时会被删除。</p>
<p>不commit谁知道你数据下完没有。</p>
<p>&nbsp;</p>
<p>2. CLEAN：</p>
<p>commit之后就会再写入一条CLEAN记录，后面依然是键名，再后面是缓存的大小。这时候这条缓存就算写入完成了。</p>
<p>&nbsp;</p>
<p>3. REMOVE：</p>
<p>写入缓存之后不commit而是调用Editor.abort()或者调用DiskLruCache.remove(String key)方法删除一条已有的缓存时，会写出一条REMOVE记录，后面还是键名我都懒得说了。</p>
<p>abort之后会删除已写入的缓存文件，和不commit的情况略有不同。</p>
<p>&nbsp;</p>
<p>4. READ：</p>
<p>顾名思义，每调用DiskLruCache.get(String key)时写一条，不多说。</p>
<p>&nbsp;</p>
<p>日志条数达到2000条之后DLC会自动清理日志，不需要担心大小问题。</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('949a359e-db06-4bb3-8bd9-28460f4bcadd')"><img id="code_img_closed_949a359e-db06-4bb3-8bd9-28460f4bcadd" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_949a359e-db06-4bb3-8bd9-28460f4bcadd" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('949a359e-db06-4bb3-8bd9-28460f4bcadd',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_949a359e-db06-4bb3-8bd9-28460f4bcadd" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> com.mlxy.disklrucachetest.util;
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.IOException;
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.InputStream;
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.HttpURLConnection;
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.URL;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> NetworkAdministrator {
</span><span style="color: #008080;"> 9</span>     <span style="color: #008000;">/**</span><span style="color: #008000;"> 打开指定地址的输入流。 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> InputStream openUrlInputStream(String url) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008080;">11</span>         HttpURLConnection urlConnection = (HttpURLConnection) <span style="color: #0000ff;">new</span><span style="color: #000000;"> URL(url).openConnection();
</span><span style="color: #008080;">12</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> urlConnection.getInputStream();
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">14</span> }</pre>
</div>
<span class="cnblogs_code_collapse">没啥好说的的类A</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('b34fab88-b4d7-488a-aedd-c8f7e5d8b9a9')"><img id="code_img_closed_b34fab88-b4d7-488a-aedd-c8f7e5d8b9a9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b34fab88-b4d7-488a-aedd-c8f7e5d8b9a9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b34fab88-b4d7-488a-aedd-c8f7e5d8b9a9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b34fab88-b4d7-488a-aedd-c8f7e5d8b9a9" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> com.mlxy.disklrucachetest.util;
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.security.MessageDigest;
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.security.NoSuchAlgorithmException;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Digester {
</span><span style="color: #008080;"> 7</span>     <span style="color: #008000;">/**</span><span style="color: #008000;"> 对数据作MD5加密。 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> String hashUp(String src) {
</span><span style="color: #008080;"> 9</span>         String hash = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;">12</span>             <span style="color: #0000ff;">byte</span>[] md5 = MessageDigest.getInstance("md5"<span style="color: #000000;">).digest(src.getBytes());
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span>             StringBuilder builder = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder();
</span><span style="color: #008080;">15</span>             <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">byte</span><span style="color: #000000;"> b : md5) {
</span><span style="color: #008080;">16</span>                 String hex = Integer.toHexString(0xff &amp;<span style="color: #000000;"> b);
</span><span style="color: #008080;">17</span>                 <span style="color: #0000ff;">if</span> (hex.length() == 1<span style="color: #000000;">) {
</span><span style="color: #008080;">18</span>                     builder.append('0'<span style="color: #000000;">);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span> <span style="color: #000000;">                builder.append(hex);
</span><span style="color: #008080;">22</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">23</span>             hash =<span style="color: #000000;"> builder.toString();
</span><span style="color: #008080;">24</span>         } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (NoSuchAlgorithmException e) {
</span><span style="color: #008080;">25</span> <span style="color: #000000;">            e.printStackTrace();
</span><span style="color: #008080;">26</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> hash;
</span><span style="color: #008080;">29</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">30</span> }</pre>
</div>
<span class="cnblogs_code_collapse">等会细说的类B</span></div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>最后祝你，身体健康，再见。</p>
<p><img src="http://images0.cnblogs.com/blog2015/580469/201506/191552037639653.jpg" alt="" /></p>

<p align=right><span style="font-size: 12px">——本文由博客园搬家工具<a href="https://github.com/mlxy/SRBCnblogs">SRBCnblogs</a>转换而成</span></p>