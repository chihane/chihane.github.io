---
layout: post
title: 【Forge】Minecraft 1.7.10 Mod开发研究 - 黑猫背包MOD 【06-给你唱一首岁月的歌】
date: 2015-01-17 04:28:00
categories: cnblogs
---

<p>老实说我已经忘了这个mod是怎么写出来的了。</p>
<p>所以下面的代码不能运行是非常正常的。</p>
<p>&nbsp;</p>
<p>上回书说到，我们处理了玩家拿着背包右键时触发的事件，发送了一条打开背包窗口的命令，但是背包窗口还没有写，这回就来解决这个问题。</p>
<p>这次因为嵌套关系太多，所以我按执行顺序反过来说。</p>
<p>那么先不管上次没有打开的那个GUI。</p>
<p>&nbsp;</p>
<p>MC中的每一个能放进物品的容器，不管是箱子、熔炉还是酿造台，各自都持有一个自己的内容空间(Inventory)实例，在这个内容空间中各自保存自己的内容物。</p>
<p>内容空间的基类是InventoryBasic，实现了IInventory接口，为了方便，咱直接继承InventoryBasic类。</p>
<p>InventoryBasic类已经实现了大部分内容空间需要的功能，可以粗读一下代码，挺好懂的。</p>
<p>于是我们黑猫背包的内容空间类只需要处理内容物的保存和读取。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d83aafb8-d534-4ca5-8a32-86e46870c8da')"><img id="code_img_closed_d83aafb8-d534-4ca5-8a32-86e46870c8da" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d83aafb8-d534-4ca5-8a32-86e46870c8da" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d83aafb8-d534-4ca5-8a32-86e46870c8da',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d83aafb8-d534-4ca5-8a32-86e46870c8da" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> InventoryKuroNeko <span style="color: #0000ff;">extends</span><span style="color: #000000;"> InventoryBasic {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String TITLE = "黑猫"<span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SLOTS_PER_LINE = 9<span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> LINES = 2<span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span>     
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> ItemStack itemStack;
</span><span style="color: #008080;"> 7</span>     
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> String id;
</span><span style="color: #008080;"> 9</span>     
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> InventoryKuroNeko(ItemStack itemStack) {
</span><span style="color: #008080;">11</span>         <span style="color: #0000ff;">super</span>(TITLE, <span style="color: #0000ff;">true</span>, LINES *<span style="color: #000000;"> SLOTS_PER_LINE);
</span><span style="color: #008080;">12</span>         
<span style="color: #008080;">13</span>         <span style="color: #0000ff;">this</span>.itemStack =<span style="color: #000000;"> itemStack;
</span><span style="color: #008080;">14</span>         
<span style="color: #008080;">15</span>         <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">itemStack.hasTagCompound()) {
</span><span style="color: #008080;">16</span>             itemStack.setTagCompound(<span style="color: #0000ff;">new</span><span style="color: #000000;"> NBTTagCompound());
</span><span style="color: #008080;">17</span>             id =<span style="color: #000000;"> UUID.randomUUID().toString();
</span><span style="color: #008080;">18</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">19</span>         
<span style="color: #008080;">20</span> <span style="color: #000000;">        readFromNBT(itemStack.getTagCompound());
</span><span style="color: #008080;">21</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">22</span>     
<span style="color: #008080;">23</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> NBTTagCompound writeToNBT(NBTTagCompound compound) {
</span><span style="color: #008080;">24</span>         NBTTagList items = <span style="color: #0000ff;">new</span><span style="color: #000000;"> NBTTagList();
</span><span style="color: #008080;">25</span>         
<span style="color: #008080;">26</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; getSizeInventory(); i++<span style="color: #000000;">) {
</span><span style="color: #008080;">27</span>             ItemStack itemStack =<span style="color: #000000;"> getStackInSlot(i);
</span><span style="color: #008080;">28</span>             <span style="color: #0000ff;">if</span> (itemStack != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">29</span>                 NBTTagCompound item = <span style="color: #0000ff;">new</span><span style="color: #000000;"> NBTTagCompound();
</span><span style="color: #008080;">30</span>                 item.setInteger("slot"<span style="color: #000000;">, i);
</span><span style="color: #008080;">31</span> <span style="color: #000000;">                itemStack.writeToNBT(item);
</span><span style="color: #008080;">32</span> <span style="color: #000000;">                items.appendTag(item);
</span><span style="color: #008080;">33</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">34</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">35</span>         
<span style="color: #008080;">36</span>         compound.setTag("items"<span style="color: #000000;">, items);
</span><span style="color: #008080;">37</span>         
<span style="color: #008080;">38</span>         compound.setString("id"<span style="color: #000000;">, id);
</span><span style="color: #008080;">39</span>         
<span style="color: #008080;">40</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> compound;
</span><span style="color: #008080;">41</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">42</span>     
<span style="color: #008080;">43</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> readFromNBT(NBTTagCompound compound) {
</span><span style="color: #008080;">44</span>         <span style="color: #0000ff;">if</span> (id == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">45</span>             id = compound.getString("id"<span style="color: #000000;">);
</span><span style="color: #008080;">46</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">47</span>         <span style="color: #0000ff;">if</span> (id == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">48</span>             id =<span style="color: #000000;"> UUID.randomUUID().toString();
</span><span style="color: #008080;">49</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">50</span>         
<span style="color: #008080;">51</span>         NBTTagList items = compound.getTagList("items", 10<span style="color: #000000;">);
</span><span style="color: #008080;">52</span>         
<span style="color: #008080;">53</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; items.tagCount(); i++<span style="color: #000000;">) {
</span><span style="color: #008080;">54</span>             NBTTagCompound item =<span style="color: #000000;"> items.getCompoundTagAt(i);
</span><span style="color: #008080;">55</span>             
<span style="color: #008080;">56</span>             <span style="color: #0000ff;">int</span> slot = item.getInteger("slot"<span style="color: #000000;">);
</span><span style="color: #008080;">57</span>             <span style="color: #0000ff;">if</span> (slot &gt;= 0 &amp;&amp; slot &lt;<span style="color: #000000;"> getSizeInventory()) {
</span><span style="color: #008080;">58</span>                 ItemStack itemStack =<span style="color: #000000;"> ItemStack.loadItemStackFromNBT(item);
</span><span style="color: #008080;">59</span> <span style="color: #000000;">                setInventorySlotContents(slot, itemStack);
</span><span style="color: #008080;">60</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">61</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">62</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">63</span>     
<span style="color: #008080;">64</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">65</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> markDirty() {
</span><span style="color: #008080;">66</span>         <span style="color: #0000ff;">super</span><span style="color: #000000;">.markDirty();
</span><span style="color: #008080;">67</span>         writeToNBT(<span style="color: #0000ff;">this</span><span style="color: #000000;">.itemStack.stackTagCompound);
</span><span style="color: #008080;">68</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">69</span> }</pre>
</div>
<span class="cnblogs_code_collapse">先扔代码</span></div>
<p>自己写两个方法，名字可以随便起，我这里一个叫writeToNBT，用于保存内容物，一个叫readFromNBT，用于读取内容物。</p>
<p>保存和读取用到的是NBT机制，NBT全称是什么我已经忘了。</p>
<p>先说保存。</p>
<p>首先创建一个NBT的列表NBTTagList，用于保存各个物品和它们的位置。这个类可以简单理解为一个列表。</p>
<p>然后遍历所有内容空间中的格子，只要发现格子中有物品，就把当前的格子位置保存在一个NBTTagCompound中，这个类理解为一个存储单元。</p>
<p>光保存位置不够，调用现成的API把这个物品的信息也加到存储单元中。</p>
<p>最后把这个存储单元添加到列表里。</p>
<p>这样遍历下来，所有物品的信息都保存起来了，最后把这个列表放到参数中传来的存储单元中。</p>
<p>怎么处理参数中的那个存储单元就不是你的事了。</p>
<p>&nbsp;</p>
<p>最后是writeToNBT这个方法的调用，按照经验，应该会有一个回调方法，由系统在需要保存内容空间的内容的时候自动调用。</p>
<p>确实有。</p>
<p>找得我好苦啊。</p>
<p>重写父类的markDirty方法，先调用一遍父类的实现，然后加上</p>
<div class="cnblogs_code">
<pre>writeToNBT(<span style="color: #0000ff;">this</span>.itemStack.stackTagCompound);</pre>
</div>
<p>这里的itemStack指的是使用了这个内容空间的物品，也就是黑猫背包。</p>
<p>在构造方法里接收并保存一下就好了。</p>
<p>&nbsp;</p>
<p>这样系统就会自动把背包中的所有物品保存到这个背包实例中了。</p>
<p>&nbsp;</p>
<p>但是光保存不行，还得读取。</p>
<p>于是来处理readFromNBT。</p>
<p>首先回到构造方法里。</p>
<p>第一次打开背包的时候肯定是不会有已经保存了的内容物的，this.itemStack.stackTagCompound这个东西也是不存在的，所以判断一下，初始化一个。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">itemStack.hasTagCompound()) {
    itemStack.setTagCompound(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> NBTTagCompound());
    id </span>=<span style="color: #000000;"> UUID.randomUUID().toString();
}</span></pre>
</div>
<p>再给当前内容空间一个id用来识别不同的背包。</p>
<p>不作id的区分的话就变成末影背包了。</p>
<p>&nbsp;</p>
<p>现在已经不会有空指针的问题了，于是不管三七二十一，读取一下吧。</p>
<p>我这上面用访问器下面直接访问变量效果是一样的，请不要在意。</p>
<p>首先从物品中保存的存储单元中拿到当前内容空间的id。</p>
<p>然后取出在刚才保存了所有物品的列表NBTTagList，这个方法的第二个参数我忘了是干嘛用的了，照抄吧。</p>
<p>接下来就是遍历了，拿出一个存储单元，找出格子的位置，然后用ItemStack类中的方法和存储单元中保存的信息创建一个物品栈并设置到指定的位置上。</p>
<p>就完美地恢复了之前保存的东西。</p>
<p>&nbsp;</p>
<p>最后说一下三个常量。</p>
<p>TITLE是内容空间的名称，貌似会显示在界面上。</p>
<p>因为为了方便之后会直接拿箱子的界面来用，所以SLOTS_PER_LINE请不要乱动。</p>
<p>LINES就是行数了，我为了平衡给了个2，箱子貌似是4？给65535应该也是可行的。如果你显示器纵向分辨率有那么高的话&hellip;&hellip;</p>
<p>&nbsp;</p>
<p>写到这里背包的基本功能就已经完成了，后面就要开始蛋疼了。</p>
<p>如刚才所说，我打算直接复用箱子的界面，但是箱子相关的两个类都用了硬编码，所以没办法用继承的方式来创建背包的界面。</p>
<p>用英文说就是用了一个非常蛋疼的workaround。</p>
<p>&nbsp;</p>
<p>下一篇再说。</p>

<div align=right><a href="https://github.com/mlxy/SRBCnblogs"><font size=1>——本文由博客园搬家工具SRBCnblogs转换而成</font></a></div>