---

layout: post

title: 再多聊点消息处理机制

date: 2016-03-10 19:16

categories: Android

tags: [android]

---

我们以银行来举例。

柜员相当于Handler。

客户相当于Message。

我们再假设有这么个叫号员，把他当做Looper。

单纯把排号的队伍当做MessageQueue是不成的，因为可能有些领导也来办业务，他们的优先级比较高，这就是Message的priority的概念。

先不讨论VIP室的问题好吗这位同学。

所以我们假设有这么一位叫号员，他就站在大厅里负责喊号。

“下一位，刘局长。”

“下一位，赵总。”

“下一位，A5。“

这时候又来了一位大人物，于是其他市民就又往后推了一名。

“下一位，孙科长。”

大概就是这么个过程。



那么问题来了，挖为什么非要搞这么一套系统呢你给我闭嘴。

第一个问题在于，一个柜员在同一时间只能做一件事，但可能会有许多个客户一起来办业务，十几个人一起涌向柜台是不行的，柜员根本处理不过来，所以需要弄一套排队系统。

另一种情况是，每一个客户取钱的目的是不一样的。

假如来了一个客户，跟柜员说我打算买一辆车拉货，你帮我上网查查哪辆车性价比高，那柜员肯定崩溃了。

一则我可能不懂这些，再则我上班很忙的，真的没时间帮您干这个，还是麻烦您回家查好了，我只负责帮您取钱您看行吗。

这也就是Handler的最常见用途，线程间调度。

我们知道Android中界面的绘制是在主线程完成的，而且每16毫秒是一个绘制周期，如果主线程被其他任务连续占用了16毫秒以上，导致当前绘制周期被占用过去了，表现在实际使用中就是点了按钮没

反应，或是动画一卡一卡不流畅。

所以我们要处理文件读写或网络连接这样的长时间任务时就会新开一个线程执行，只在需要更新界面的时候发送一条消息，由主线程的Looper来把消息在主线程中取出并交由Handler来处理。	

发送Message的线程可能有很多个，但是最终都会回到Looper所在的线程，这也就是要在新线程使用Handler前必须调用Looper.prepare()，在新线程手动开启Looper的原因。