---
layout: post
title: 讲讲消灭星星的算法实现思路吧
date: 2014-06-12 02:14:00
categories: cnblogs
---

<p>这个游戏的关键算法是选取同色区域。</p>
<p>我的方法是每个方块是一个对象，包含几项属性：自身所在的行，自身所在的列，自身的颜色。</p>
<p>还加了一个id作备用，暂时没用到。</p>
<p>&nbsp;</p>
<p>基本思路是递归，显而易见。</p>
<p>首先准备两个列表。</p>
<p>一个用来装被检查过了的方块，因为左边方块的右边就等于右边方块的左边，如果不检查的话就无限递归到溢出了。</p>
<p>另一个用来装与传入方块颜色相同的方块，留待递归完成后作为返回值。</p>
<p>&nbsp;</p>
<p>然后传入第一个方块，分别检查它四个方向上的方块，如果颜色和它相同的话就用对应方向上的方块来进行下一次递归。</p>
<p>上方检测举例，其他方向同理：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> checkUp(Block block) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 越界(上方不存在方块)则跳出。</span>
    <span style="color: #0000ff;">if</span> ((block.getRow()-1) &lt; 0<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取上方方块。</span>
    Block blockUpside = GameSurfaceView.blockList[block.getRow()-1<span style="color: #000000;">][block.getColumn()];
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果方块不存在或者颜色不同就跳出。</span>
    <span style="color: #0000ff;">if</span> (blockUpside == <span style="color: #0000ff;">null</span> || blockUpside.getColor() !=<span style="color: #000000;"> block.getColor()) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 下一次递归。</span>
<span style="color: #000000;">    checkFourSides(blockUpside);
}</span></pre>
</div>
<p>&nbsp;</p>
<p>跳出递归的唯一条件是当前方块有没有被检查过，因为考虑到单一职责原则，我把方块对比的代码都放到了单个方向检测的方法里了，包括是否越界和颜色是否相同还有对应方向上的方块存不存在。</p>
<p>这些是找到了对应方向上的方块才有讨论的必要的。</p>
<p>比如我看到的那个C++的条件判断是这样的&hellip;&hellip;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('283023c1-7b0e-4689-b9e7-743d187f0b25')"><img id="code_img_closed_283023c1-7b0e-4689-b9e7-743d187f0b25" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_283023c1-7b0e-4689-b9e7-743d187f0b25" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('283023c1-7b0e-4689-b9e7-743d187f0b25',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_283023c1-7b0e-4689-b9e7-743d187f0b25" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">递归求解</span>
<span style="color: #0000ff;">void</span> MyRecursion(LinkList _head1, LinkList _head2, <span style="color: #0000ff;">int</span> _x, <span style="color: #0000ff;">int</span> _y, <span style="color: #0000ff;">int</span><span style="color: #000000;"> number) {
    </span><span style="color: #0000ff;">if</span> ((_x &gt;= <span style="color: #800080;">10</span>) || (_x &lt; <span style="color: #800080;">0</span>) || (_y &gt;= <span style="color: #800080;">10</span>) || (_y &lt; <span style="color: #800080;">0</span><span style="color: #000000;">)
            </span>|| (MyTraverseLinkList(_head2, _x, _y)) || (<span style="color: #800080;">0</span> ==<span style="color: #000000;"> MyArray[_x][_y])) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        MyInsertLinkList(_head2, _x, _y);
        </span><span style="color: #0000ff;">if</span> ((MyArray[_x][_y] ==<span style="color: #000000;"> number)) {
            MyInsertLinkList(_head1, _x, _y);
            </span><span style="color: #0000ff;">if</span> ((_x - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span>)    <span style="color: #008000;">//</span><span style="color: #008000;">递归 - 上</span>
<span style="color: #000000;">                    {
                MyRecursion(_head1, _head2, _x </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, _y, number);
            }
            </span><span style="color: #0000ff;">if</span> ((_y - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span>)    <span style="color: #008000;">//</span><span style="color: #008000;">递归 - 左</span>
<span style="color: #000000;">                    {
                MyRecursion(_head1, _head2, _x, _y </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, number);
            }
            </span><span style="color: #0000ff;">if</span> ((_x + <span style="color: #800080;">1</span>) &lt; <span style="color: #800080;">10</span>)    <span style="color: #008000;">//</span><span style="color: #008000;">递归 - 下</span>
<span style="color: #000000;">                    {
                MyRecursion(_head1, _head2, _x </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, _y, number);
            }
            </span><span style="color: #0000ff;">if</span> ((_y + <span style="color: #800080;">1</span>) &lt; <span style="color: #800080;">10</span>)    <span style="color: #008000;">//</span><span style="color: #008000;">递归 - 右</span>
<span style="color: #000000;">                    {
                MyRecursion(_head1, _head2, _x, _y </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, number);
            }
        }
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">姐夫你不要这样你是有对象的啊</span></div>
<p>里面还有重复的边界判断。</p>
<p>而且这哥们的起名姿势很有特点。</p>
<p>&nbsp;</p>
<p>如果一个方法只做一件事的话，思路就清晰多了，像这样。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/**</span><span style="color: #008000;"> 递归，不停检查四面。</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> checkFourSides(Block block) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果当前方块已被检查过，则跳出当前递归。</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (isChecked(block)) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 标记当前方块为已被检查过。</span>
<span style="color: #000000;">    checkedBlocks.add(block);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将当前方块加入同色列表。</span>
<span style="color: #000000;">    blocksInSameColor.add(block);
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 检查上下左右的方块。</span>
<span style="color: #000000;">    checkUp(block);
    checkDown(block);
    checkLeft(block);
    checkRight(block);
}</span></pre>
</div>
<p>&nbsp;</p>
<p>于是像这样，当检查方法碰到边界，或者碰到了不存在的方块，或者周围已经没有颜色相同的方块了的时候，递归停止。</p>
<p>最后同色列表里保存的就是首尾相连的一片同色方块了。</p>
<p>然后把整个算法封装起来，再对外暴露一个接口就搞定了。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/**</span><span style="color: #008000;"> 获取存有与当前方块颜色相同首尾相连的一片方块的列表。</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> ArrayList&lt;Block&gt;<span style="color: #000000;"> getBlocksInSameColor(Block selectedBlock) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 初始化两个缓存列表。</span>
    checkedBlocks = <span style="color: #0000ff;">new</span> ArrayList&lt;Block&gt;<span style="color: #000000;">();
    blocksInSameColor </span>= <span style="color: #0000ff;">new</span> ArrayList&lt;Block&gt;<span style="color: #000000;">();
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行递归。</span>
<span style="color: #000000;">    checkFourSides(selectedBlock);
    
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> blocksInSameColor;
}</span></pre>
</div>
<p>&nbsp;</p>

<div align=right><a href="https://github.com/mlxy/SRBCnblogs"><font size=1>——本文由博客园搬家工具SRBCnblogs转换而成</font></a></div>