---
layout: post
title: 设计模式，2/23，工厂模式
date: 2014-03-16 11:42:00
categories: cnblogs
---

<p>博客园太难用了，第二页居然连摘要都显示不出来了，选列出标题也没用，选列出摘要也没用。</p>
<p>而且都说第一页全部显示了居然还是只显示摘要，怎么让所有博文都不折叠，在列表里就全显示出来&hellip;&hellip;</p>
<p>&nbsp;</p>
<p>还是顾名思义，用一个工厂类来生产对象。</p>
<p>我一开始以为传入的参数是对象，还心想传入对象输出对象这不是有病么，后来发现参数是个类。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4f69102f-0ee7-4728-87dc-197949f5de2f')"><img id="code_img_closed_4f69102f-0ee7-4728-87dc-197949f5de2f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4f69102f-0ee7-4728-87dc-197949f5de2f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4f69102f-0ee7-4728-87dc-197949f5de2f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4f69102f-0ee7-4728-87dc-197949f5de2f" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ProductFactory {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> Product product = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>     
<span style="color: #008080;"> 4</span>     @SuppressWarnings("unchecked"<span style="color: #000000;">)
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> &lt;T <span style="color: #0000ff;">extends</span> Product&gt; T createProduct(Class&lt;T&gt;<span style="color: #000000;"> c) {
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>             product =<span style="color: #000000;"> (Product) Class.forName(c.getName()).newInstance();
</span><span style="color: #008080;"> 8</span>         } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">            e.printStackTrace();
</span><span style="color: #008080;">10</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">11</span>         
<span style="color: #008080;">12</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> (T) product;
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">14</span> }</pre>
</div>
<span class="cnblogs_code_collapse">Product可以替换成任意产品名</span></div>
<p>为了避免看不懂。</p>
<p>Product接口是这个样子的。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> Product {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printName();
}</span></pre>
</div>
<p>不管怎么样，先测试一下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1bcd26c3-d745-4eb0-b4d5-ab38917199be')"><img id="code_img_closed_1bcd26c3-d745-4eb0-b4d5-ab38917199be" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1bcd26c3-d745-4eb0-b4d5-ab38917199be" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1bcd26c3-d745-4eb0-b4d5-ab38917199be',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1bcd26c3-d745-4eb0-b4d5-ab38917199be" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 3</span>         ProductFactory factory = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ProductFactory();
</span><span style="color: #008080;"> 4</span>         
<span style="color: #008080;"> 5</span>         Product one = factory.createProduct(Product1.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        one.printName();
</span><span style="color: #008080;"> 7</span>         System.out.println(one <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Product1);
</span><span style="color: #008080;"> 8</span>         Product two = factory.createProduct(Product2.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">        two.printName();
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span> }</pre>
</div>
<span class="cnblogs_code_collapse">测试类</span></div>
<p>输出结果：</p>
<p>I am testFactory.Product1<br />true<br />I am testFactory.Product2<br /><br /></p>
<p>测试完毕，输出都正常，第二句输出还证明了返回的对象确实是Product1类型的，说明工厂类确实能满足需要。</p>
<p>&nbsp;</p>
<p>解释下工厂类。</p>
<p>类中包含一个属性，预先定义了要输出的对象。</p>
<p>然后类中有一个方法，用来产生产品对象，具体的过程是传入一个类，然后用Class类的newInstance()方法来产生一个实例并将其返回。</p>
<p>forName()方法的作用是输入类名返回class对象，但是介于我们传入工厂方法的参数它就是一个class对象，所以总感觉这一步有点多余。</p>
<p>&hellip;&hellip;总之禅里是这么写的，我就照搬了。</p>
<p>&hellip;&hellip;&hellip;&hellip;我改了去测试一下&hellip;&hellip;</p>
<p>&nbsp;</p>
<p>&hellip;&hellip;测试完成。</p>
<p>直接这样</p>
<div class="cnblogs_code">
<pre>product = (Product) c.newInstance();</pre>
</div>
<p>就可以了，不用forName()也成。</p>
<p>&nbsp;</p>
<p>newInstance()方法会抛两个异常，不过用IDE的话反正会有异常提示的，就不说了。</p>
<p>&nbsp;</p>
<p>再一个，这段代码里用到了泛型，对的这个用法也是照搬的&hellip;&hellip;不过我保证这些代码都是我回忆着敲的没有对着书抄&hellip;&hellip;</p>
<p>以下内容是自己推测的不保证对。</p>
<p>&lt;T extends Product&gt;一句定义了泛型的类型，然后用在返回类型和输入参数类型里，保证了传入和输出的一定是Product，因为这个工厂根本也不处理别的类型。</p>
<p>往服装厂里传入一块粘土说我要红砖不太对不是。</p>
<p>最后的返回结果直接是product是不行的，因为方法头里定义了返回类型是T，尽管返回值就是Product类型，于是要加上强制转换。</p>
<p>但是强制转换之后eclipse报警告了，跟我说返回之前你得检查一下返回值是不是T。<span style="text-decoration: line-through;">万一是个P呢？</span></p>
<p>然后我百度谷歌了一下，大家纷纷表示它就是这样的改不了SUN罪大恶极搞到百姓怨声载道而且warning不算错误要不你就屏蔽掉吧。</p>
<p>我心想这怎么行，一个严谨的程序员怎么能看着一个大大的黄色三角裤不没有裤摆在眼前而无动于衷呢。</p>
<p>于是我就试了一下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span> (product <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> T) {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> (T) product;
}</span></pre>
</div>
<p>结果报了另一种错误，表示泛型是不能用instanceof的，因为在运行时，T的类型信息是被擦除了的。</p>
<p>于是我抱着试试看的心态又去stackoverflow搜了几个相关问题的回答。</p>
<p>&nbsp;</p>
<p>然后我决定不整这些没用的。</p>
<p>方法前加上</p>
<div class="cnblogs_code">
<pre>@SuppressWarnings("unchecked")</pre>
</div>
<p>搞定。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>工厂模式的适用于需要产生多个产品对象的场合，用了就知道。</p>
<p>比如我还想加上一个Product3，我只要写好实现类，然后在场景类里生产它就可以了，绝对低耦合，用户需要知道的只有类名，轻松自如，如鱼得水。</p>

<p align=right><span style="font-size: 12px">——本文由博客园搬家工具<a href="https://github.com/mlxy/SRBCnblogs">SRBCnblogs</a>转换而成</span></p>