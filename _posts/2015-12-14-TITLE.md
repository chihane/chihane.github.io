---
layout: post
title: 代码测试
date: 2015-12-14 14:20
categories: CATEGORY
tags: [TAG]
---

{% highlight java %}
package mlxy.imageloadertest;

import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.widget.ImageView;

import java.io.IOException;
import java.io.InputStream;

import mlxy.imageloadertest.lrucache.DiskLruCacheHelper;
import mlxy.imageloadertest.lrucache.LruCacheHelper;
import mlxy.imageloadertest.util.NetworkAdministrator;
import rx.Observable;
import rx.Subscriber;
import rx.android.schedulers.AndroidSchedulers;
import rx.functions.Action1;
import rx.functions.Func1;
import rx.schedulers.Schedulers;

public class ImageLoader {
    private static final int MEMORY_CACHE_SIZE_LIMIT = (int) (Runtime.getRuntime().maxMemory() / 3);
    private static final int LOCAL_CACHE_SIZE_LIMIT = 100 * 1024 * 1024;

    private static final int NETWORK_TIMEOUT = 5000;

    public ImageLoader(Context context) {
        initMemoryCache();
        initDiskCache(context);
    }

    /** 初始化内存缓存器。 */
    private void initMemoryCache() {
        LruCacheHelper.openCache(MEMORY_CACHE_SIZE_LIMIT);
    }

    /** 初始化磁盘缓存器。 */
    private void initDiskCache(Context context) {
        int appVersion = 1;
        try {
            appVersion = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionCode;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }

        DiskLruCacheHelper.openCache(context, appVersion, LOCAL_CACHE_SIZE_LIMIT);
    }

    /** 载入图片。
     *  @param imageView 要显示图片的视图。
     *  @param url 要显示的图片的URL。
     * */
    public void load(final ImageView imageView, final String url) {
        // 尝试从内存缓存载入图片。
        Observable<Bitmap> memoryObservable = loadImageFromMemory(url);
        Observable<Bitmap> diskObservable = loadImageFromDisk(url);
        Observable<Bitmap> internetObservable = loadFromInternet(url);

        Observable.concat(memoryObservable, diskObservable, internetObservable)
                .first(new Func1<Bitmap, Boolean>() {
                    @Override
                    public Boolean call(Bitmap bitmap) {
                        return bitmap != null;
                    }
                })
                .subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1<Bitmap>() {
                    @Override
                    public void call(Bitmap bitmap) {
                        imageView.setImageBitmap(bitmap);
                    }
                });
    }

    /** 从内存缓存中加载图片。 */
    private Observable<Bitmap> loadImageFromMemory(String url) {
        return LruCacheHelper.load(url);
    }

    /** 从磁盘缓存中加载图片。 */
    private Observable<Bitmap> loadImageFromDisk(final String url) {
        return DiskLruCacheHelper.load(url)
                .doOnNext(new Action1<Bitmap>() {
                    @Override
                    public void call(Bitmap bitmap) {
                        putImageIntoMemoryCache(url, bitmap);
                    }
                });
    }

    /** 从网络上下载图片。 */
    private Observable<Bitmap> loadFromInternet(final String url) {
        return Observable.create(new Observable.OnSubscribe<Bitmap>() {
            @Override
            public void call(Subscriber<? super Bitmap> subscriber) {
                try {
                    InputStream in = NetworkAdministrator.openUrlInputStream(url, NETWORK_TIMEOUT);
                    Bitmap bitmap = BitmapFactory.decodeStream(in);
                    subscriber.onNext(bitmap);
                    subscriber.onCompleted();
                } catch (IOException e) {
                    subscriber.onError(e);
                }
            }
        }).doOnNext(new Action1<Bitmap>() {
            @Override
            public void call(Bitmap bitmap) {
                putImageIntoMemoryCache(url, bitmap);
                putImageIntoDiskCache(url, bitmap);
            }
        });
    }

    /** 把图片保存到内存缓存。 */
    private void putImageIntoMemoryCache(String url, Bitmap bitmap) {
        LruCacheHelper.dump(url, bitmap);
    }

    /** 把图片保存到磁盘缓存。 */
    private void putImageIntoDiskCache(String url, Bitmap bitmap) {
        try {
            DiskLruCacheHelper.dump(bitmap, url);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /** 使用完毕必须调用。 */
    public void close() {
        DiskLruCacheHelper.closeCache();
        LruCacheHelper.closeCache();
    }
}

{% endhighlight %}

{% highlight python %}
# coding:utf-8

import sys
import xml.dom.minidom
import os
import time

reload(sys)
sys.setdefaultencoding('utf-8')

BACKUP_FILE = 'CNBlogs_BlogBackup_131_201310_201512.xml'
TAIL = '<p align=right><span style="font-size: 12px">——本文由博客园搬家工具<a href="https://github.com/mlxy/SRBCnblogs">SRBCnblogs</a>转换而成</span></p>'

DOMTree = xml.dom.minidom.parse(BACKUP_FILE)
root = DOMTree.documentElement

blog_title = root.getElementsByTagName('title')[0].childNodes[0].data

if not os.path.isdir(blog_title):
    os.mkdir(blog_title)

blogs = root.getElementsByTagName('item')

for blog in blogs:
    title = blog.getElementsByTagName('title')[0].childNodes[0].data
    origin_link = blog.getElementsByTagName('link')[0].childNodes[0].data
    date = blog.getElementsByTagName('pubDate')[0].childNodes[0].data
    content = blog.getElementsByTagName('description')[0].childNodes[0].data

    timestamp = time.mktime(time.strptime(date, '%a, %d %b %Y %H:%M:%S GMT'))
    date_filename = time.strftime('%Y-%m-%d-%H-%M', time.localtime(timestamp))
    date_header = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))

    with open(blog_title + os.sep + date_filename + '.md', 'w') as f:
        f.writelines(['---\n', 'layout: post\n', 'title: %s\n' % title, 'date: %s\n' % date_header, 'categories: cnblogs\n', '---\n\n'])
        f.write(content)
        f.write('\n\n')
        f.write(TAIL)
        f.close()

{% endhighlight %}