---
layout: post
title: Android的消息处理（Handler相关）
date: 2014-09-02 14:17:00
categories: cnblogs
---

<p>　　首先Message（消息）类不用多说，内部用what（啥）属性来存放标识符，用obj（对象）来存放要携带的数据，用target（目标）来存放目标Handler。</p>
<p>　　所以需要有一个Handler（句柄）类来处理Message，方法是调用Handler类中的sendMessage(Message)方法，我之前一直觉得这个方法名的逻辑很奇怪，现在懂了，因为知道了另一个类：</p>
<p>　　MessageQueue（消息队列），在调用sendMessage之后Handler会依次调用两个不是重载但跟重载也差不多的内部方法，最后像这样</p>
<div class="cnblogs_code">
<pre>sent = queue.enqueueMessage(msg, uptimeMillis);</pre>
</div>
<p>把Message发送（send）给内部创建的一个MessageQueue对象，同时把Message中的target属性设置为自己。</p>
<p>　　这时又要说到另一个类，Looper（循环器）。程序运行的时候安卓会在主线程里创建一个Looper，</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('75fa4f3a-3bca-48ed-b4f3-72ced1e71792')"><img id="code_img_closed_75fa4f3a-3bca-48ed-b4f3-72ced1e71792" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_75fa4f3a-3bca-48ed-b4f3-72ced1e71792" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('75fa4f3a-3bca-48ed-b4f3-72ced1e71792',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_75fa4f3a-3bca-48ed-b4f3-72ced1e71792" class="cnblogs_code_hide">
<pre><span style="color: #008080;"> 1</span>     <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;">     * Initialize the current thread as a looper, marking it as an
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">     * application's main looper. The main looper for your application
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">     * is created by the Android environment, so you should never need
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">     * to call this function yourself.  See also: {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> #prepare()}
</span><span style="color: #008080;"> 6</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> prepareMainLooper() {
</span><span style="color: #008080;"> 8</span>         prepare(<span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 9</span>         <span style="color: #0000ff;">synchronized</span> (Looper.<span style="color: #0000ff;">class</span><span style="color: #000000;">) {
</span><span style="color: #008080;">10</span>             <span style="color: #0000ff;">if</span> (sMainLooper != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">11</span>                 <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("The main Looper has already been prepared."<span style="color: #000000;">);
</span><span style="color: #008080;">12</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">13</span>             sMainLooper =<span style="color: #000000;"> myLooper();
</span><span style="color: #008080;">14</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">15</span>     }</pre>
</div>
<span class="cnblogs_code_collapse">系统调用</span></div>
<p>它以for死循环的方式不断尝试从队列中取出Message，</p>
<div class="cnblogs_code">
<pre>Message msg = queue.next();</pre>
</div>
<p>取到了就调用这个Message中的target中存放的那个Handler的dispatchMessage(Message)方法。像这样：</p>
<div class="cnblogs_code">
<pre>msg.target.dispatchMessage(msg);</pre>
</div>
<p>　　Handler用这个方法稍微进行一下判断，之后就转交给自己的handleMessage(Message)方法来处理消息，这个方法和onCreate一样是由程序员重写，由系统调用的。</p>
<p>　　剩下的就很简单了，handleMessage方法是程序员自己写的，想做点什么都行。</p>
<p>　　通常是根据Message中的what来switch一下，对于不同消息来源做出不同反应就可以啦。</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">那么总结一下</span>：</p>
<p>　　明面上程序员做两件事。</p>
<p>　　首先是创建Handler，重写好方法，决定用它来做点什么；</p>
<p>　　后面的分为两种情况。</p>
<p>　　如果调用Handler的时候需要携带信息，就用Message.obtain()方法或new关键字得到Message对象，然后使用Handler对象的sendMessage(Message)方法交由Handler处理。</p>
<p>　　如果并不需要携带额外信息，只需要通知Handler有事要做，就不需要自己得到Message对象，直接使用Handler对象的sendEmptyMessage(int)方法，Handler会像这样</p>
<div class="cnblogs_code">
<pre>Message msg =<span style="color: #000000;"> Message.obtain();
msg.what </span>= what;</pre>
</div>
<p>自己创建一个Message对象，并用方法中传入的int值作为Message的what属性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #ff0000;">第一步，定义Handler。</span></p>
<p><span style="color: #ff0000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二步，发送消息。</span></p>
<p><span style="color: #ff0000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这样。</span></p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>PS：</p>
<p>　　如果要在主线程之外使用Handler要注意一个问题。</p>
<p>　　首先按照上面说的，消息是由Looper从队列中取出并分发的，只管自己的线程。可是主线程中使用的Looper是安卓系统创建的，用户新建线程的时候并不会自动创建一个新的Looper，所以Looper告诉你</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">final</span> Looper me =<span style="color: #000000;"> myLooper();
</span><span style="color: #0000ff;">if</span> (me == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
     </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."<span style="color: #000000;">);
}</span></pre>
</div>
<p>这个，Handler告诉你</p>
<div class="cnblogs_code">
<pre>mLooper =<span style="color: #000000;"> Looper.myLooper();
</span><span style="color: #0000ff;">if</span> (mLooper == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> RuntimeException(
        </span>"Can't create handler inside thread that has not called Looper.prepare()"<span style="color: #000000;">);
}</span></pre>
</div>
<p>这个。</p>
<p>　　因此，要在新线程里创建Handler就需要调用Looper.prepare()方法来准备好一个Looper，这个方法会自动调用内部的重载方法，不需要担心。</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> prepare(<span style="color: #0000ff;">boolean</span><span style="color: #000000;"> quitAllowed) {
        </span><span style="color: #0000ff;">if</span> (sThreadLocal.get() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RuntimeException("Only one Looper may be created per thread"<span style="color: #000000;">);
        }
        sThreadLocal.set(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Looper(quitAllowed));
    }</span></pre>
</div>
<p>　　自己调用的时候参数是true，系统调用的时候是false，总之不需要在意。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　Handler用来让其他线程修改UI啊，这个不用我说吧。</p>

<div align=right><a href="https://github.com/mlxy/SRBCnblogs"><font size=1>——本文由博客园搬家工具SRBCnblogs转换而成</font></a></div>